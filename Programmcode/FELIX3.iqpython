{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nmotor_3 = Motor(Ports.PORT3, False)\nmotor_1 = Motor(Ports.PORT1, False)\ndistance_6 = Sonar(Ports.PORT6)\ndistance_8 = Distance(Ports.PORT8)\ndistance_2 = Sonar(Ports.PORT2)\n\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\nmotor_1.set_stopping(HOLD)\nmotor_3.set_stopping(HOLD)\n\n## search start position\n\n#brain_inertial.calibrate()\n#brain_inertial.set_heading(0, DEGREES)\nbrain_inertial.set_rotation(0, DEGREES)\n\n#while True:\n#    print(brain_inertial.heading(DEGREES))\n\nabstandL = distance_8.object_distance(MM)\nabstandR = distance_6.distance(MM)\n\nprint(123, abstandL, abstandR)\n\nwhile abstandL + abstandR > 1000 + 100:\n    print(abstandL, abstandR)\n    motor_3.spin_for(REVERSE, 30, DEGREES)\n    abstandL = distance_8.object_distance(MM)\n    abstandR = distance_6.distance(MM)\n\nprint('Aaaaa')\nprint(abstandL, abstandR)\nprint(abstandL + abstandR)\nprint(abstandL + abstandR > 1000 + 100)\nprint()\n\nmotor_3.spin_for(REVERSE, 120, DEGREES)\n\nwhile abstandL + abstandR < 1000 + 100:\n    print(abstandL, abstandR)\n    motor_3.spin_for(FORWARD, 30, DEGREES)\n    abstandL = distance_8.object_distance(MM)\n    abstandR = distance_6.distance(MM)\n\n\ndistanceF = distance_2.distance(MM) + 150\nmiddle = distanceF / 2\nright = abstandL - abstandR < 0\nprint(distanceF, right)\n\nbrain.play_note(3, 0, 1000)\n\n## loop\n\nwhile True:\n    ## curve\n\n    print('cvurve')\n\n    if right:\n        motor_1.spin_for(REVERSE, 58, DEGREES)\n        motor_3.spin_for(FORWARD, 375/369, TURNS)\n        motor_1.spin_for(REVERSE, -58, DEGREES)\n\n    if not right:\n        motor_1.spin_for(FORWARD, 58, DEGREES)\n        motor_3.spin_for(FORWARD, 375/360, TURNS)\n        motor_1.spin_for(FORWARD, -58, DEGREES)\n\n    motor_3.spin_for(FORWARD, 100, DEGREES)\n\n    ### drive forward\n\n    abstandL = distance_8.object_distance(MM)\n    abstandR = distance_6.distance(MM)\n    \n    position = 0\n\n    distanceF = distance_2.distance(MM) + 150\n    middle = distanceF / 2\n    right = abstandL - abstandR < 0\n    print(distanceF, right)\n\n    brain.play_note(3, 0, 1000)\n\n    position = 0\n    while abstandL + abstandR < 1000 + 100:\n        soll = (abstandL + 150 / 2) - middle\n        #sollWinkel = 58 * soll/distanceF\n        winkel = 30 if soll < 0 else -30\n        #if abs(soll) < 100:\n        #    winkel = 0\n        if not position == winkel:\n            motor_1.spin_for(REVERSE, winkel-position, DEGREES)\n            position = winkel\n        #position = -sollWinkel\n        print(abstandL, abstandR, soll)\n        motor_3.spin_for(FORWARD, 30, DEGREES)\n        #motor_1.spin_for(FORWARD, winkel, DEGREES)\n        abstandL = distance_8.object_distance(MM)\n        abstandR = distance_6.distance(MM)\n    \n    motor_1.spin_for(FORWARD, position, DEGREES)\n\n    #motor_1.spin_for(REVERSE, position, DEGREES)","textLanguage":"python","rconfig":[],"slot":0,"platform":"IQ","sdkVersion":"20211210.18.00.00","appVersion":"2.3.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"Second","target":"Physical"}